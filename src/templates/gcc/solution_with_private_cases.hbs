#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "cJSON.h"

// USER CODE IS SUBSTITUTED HERE
{{{user_code}}}

// Public test cases JSON string
const char* publicTestCasesJson = "{{{jsonEscaped public_test_cases}}}";
// Private test cases JSON string
const char* privateTestCasesJson = "{{{jsonEscaped private_test_cases}}}";

{{#each languageSpecificParameters}}
{{#if (eq runtime "gcc")}}

// Test execution function
void executeTests() {
    cJSON* publicRoot = cJSON_Parse(publicTestCasesJson);
    cJSON* privateRoot = cJSON_Parse(privateTestCasesJson);

    if (!publicRoot && !privateRoot) {
        printf("{\"error\": \"Failed to parse test cases JSON\"}\n");
        return;
    }

    int publicTotal = publicRoot ? cJSON_GetArraySize(publicRoot) : 0;
    int privateTotal = privateRoot ? cJSON_GetArraySize(privateRoot) : 0;
    int total = publicTotal + privateTotal;
    int passed = 0;
    int failed = 0;
    int errors = 0;
    int publicPassed = 0;
    int privatePassed = 0;

    // --- Start Test Loop Logic ---
    cJSON* roots[2] = {publicRoot, privateRoot};
    int totals[2] = {publicTotal, privateTotal};
    int* passedCounters[2] = {&publicPassed, &privatePassed};

    for (int rootIndex = 0; rootIndex < 2; rootIndex++) {
        cJSON* root = roots[rootIndex];
        int currentTotal = totals[rootIndex];
        int* currentPassed = passedCounters[rootIndex];
        
        if (root) {
            for (int i = 0; i < currentTotal; i++) {
                cJSON* testCase = cJSON_GetArrayItem(root, i);
                if (!testCase) { errors++; continue; }

                cJSON* inputObj = cJSON_GetObjectItem(testCase, "input");
                cJSON* expectedObj = cJSON_GetObjectItem(testCase, "output");

                if (!inputObj || !expectedObj) { errors++; continue; }

                // Extract parameters
                {{#each parameters}}
                {{#if (eq type "int")}}
                cJSON* param_{{@index}} = cJSON_GetObjectItem(inputObj, "{{name}}");
                if (!param_{{@index}}) { errors++; continue; }
                int {{name}} = param_{{@index}}->valueint;
                {{else if (or (eq type "std::string") (eq type "char*") (eq type "string"))}}
                cJSON* param_{{@index}} = cJSON_GetObjectItem(inputObj, "{{name}}");
                if (!param_{{@index}}) { errors++; continue; }
                char* {{name}} = param_{{@index}}->valuestring;
                {{else if (eq type "double")}}
                cJSON* param_{{@index}} = cJSON_GetObjectItem(inputObj, "{{name}}");
                if (!param_{{@index}}) { errors++; continue; }
                double {{name}} = param_{{@index}}->valuedouble;
                {{else if (eq type "float")}}
                cJSON* param_{{@index}} = cJSON_GetObjectItem(inputObj, "{{name}}");
                if (!param_{{@index}}) { errors++; continue; }
                float {{name}} = (float)param_{{@index}}->valuedouble;
                {{else if (eq type "bool")}}
                cJSON* param_{{@index}} = cJSON_GetObjectItem(inputObj, "{{name}}");
                if (!param_{{@index}}) { errors++; continue; }
                int {{name}} = cJSON_IsTrue(param_{{@index}});
                {{/if}}
                {{/each}}

                // Call function
                // The parameters for your specific problem (Longest Substring) are: char* s
                // The return type is: int
                
                // VVV Fix/Confirmation for Longest Substring VVV
                {{#if (eq return_type "int")}}
                int result = {{../function_name}}({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
                int expected = expectedObj->valueint;
                int testPassed = (result == expected);
                {{else if (or (eq return_type "std::string") (eq return_type "char*") (eq return_type "string"))}}
                char* result = {{../function_name}}({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
                char* expected = expectedObj->valuestring;
                int testPassed = (result && expected && strcmp(result, expected) == 0);
                {{else if (eq return_type "double")}}
                double result = {{../function_name}}({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
                double expected = expectedObj->valuedouble;
                int testPassed = (fabs(result - expected) < 1e-9);
                {{else if (eq return_type "float")}}
                float result = {{../function_name}}({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
                float expected = (float)expectedObj->valuedouble;
                int testPassed = (fabsf(result - expected) < 1e-6);
                {{else if (eq return_type "bool")}}
                int result = {{../function_name}}({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
                int expected = cJSON_IsTrue(expectedObj);
                int testPassed = (result == expected);
                {{/if}}
                // ^^^ End Fix/Confirmation ^^^

                if (testPassed) {
                    passed++;
                    (*currentPassed)++;
                } else {
                    failed++;
                }
            }
        }
    }
    // --- End Test Loop Logic ---

    // Calculate score
    int score = total > 0 ? (passed * 100) / total : 0;

    // Output results in same format as JS
    printf("{\"total\": %d, \"passed\": %d, \"failed\": %d, \"errors\": %d, \"score\": %d, \"publicTests\": {\"total\": %d, \"passed\": %d}, \"privateTests\": {\"total\": %d, \"passed\": %d}}\n",
           total, passed, failed, errors, score, publicTotal, publicPassed, privateTotal, privatePassed);

    if (publicRoot) cJSON_Delete(publicRoot);
    if (privateRoot) cJSON_Delete(privateRoot);
}

int main() {
    executeTests();
    return 0;
}

{{/if}}
{{/each}}